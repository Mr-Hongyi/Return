@inherits SubscribingComponent<Return.Application.Notifications.NoteAdded.INoteAddedSubscriber>
@implements Return.Application.Notifications.NoteAdded.INoteAddedSubscriber
@inject ILogger<NoteLane> Logger
@using Microsoft.Extensions.Logging
@using Return.Application.Common.Models
@using Return.Application.Notes.Commands.AddNote
@using Return.Application.Notifications.NoteAdded
@using Return.Application.RetrospectiveLanes.Queries
@using Return.Application.Retrospectives.Queries.GetRetrospectiveStatus
@using Return.Domain.ValueObjects

@if (this.Lane == null)
{
    return;
}

<h2 class="title has-text-centered">@Lane.Name</h2>

@if (this.Contents == null)
{
    return;
}

@foreach (RetrospectiveNote note in this.Contents.Notes)
{
    <Note @key="note.Id" Data="@note"/>
}

@if (this.RetrospectiveStatus?.IsEditingNotesAllowed == true)
{
    @if (this.ShowErrorMessage)
    {
        <ErrorMessage />
    }

    <p class="has-text-centered">
        <button type="button" class="button is-link is-outlined" @onclick="@AddNote">
            Add a note
        </button>    
    </p>
}
 
@code {

    #nullable disable

    [Parameter]
    public RetrospectiveLane Lane { get; set; }

    [CascadingParameter]
    public CurrentParticipantModel CurrentParticipant { get; set; }

    [CascadingParameter]
    public RetrospectiveStatus RetrospectiveStatus { get; set; }

    [CascadingParameter]
    public RetroIdentifier RetroId { get; set; }

    private RetrospectiveLaneContent Contents { get; set; }

    private bool ShowErrorMessage { get; set; }

    private bool? _isShowingNotes;

    protected override Task OnInitializedAsync() => this.Load();

    private async Task Load()
    {
        this.Contents = await this.Mediator.Send(new GetRetrospectiveLaneContentQuery(this.RetroId.StringId, this.Lane?.Id ?? 0));
    }

    private async Task Refresh()
    {
        await this.Load();
        this.StateHasChanged();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (this.RetrospectiveStatus != null)
        {
            HandleNoteChange();

            this._isShowingNotes = this.RetrospectiveStatus.IsViewingOtherNotesAllowed;
        }
    }

    /// <summary>
    /// When the notes were not revealed they actually contain garbage data. It has the same length of the words,
    /// but isn't the words. We need to reveal the notes by re-issuing a renew.
    /// </summary>
    private void HandleNoteChange()
    {
        if (this._isShowingNotes != null && ( this.RetrospectiveStatus.IsViewingOtherNotesAllowed != this._isShowingNotes ))
        {
            this.InvokeAsync(this.Refresh);
        }
    }

    private async Task AddNote()
    {
        try
        {
            this.ShowErrorMessage = false;

            RetrospectiveNote result = await this.Mediator.Send(new AddNoteCommand(this.RetroId.StringId, this.Lane.Id));

            this.Contents.Notes.Add(result);
        }
        catch (Exception ex)
        {
            this.ShowErrorMessage = true;

            this.Logger.LogError(ex, $"Unable to add note for {this.RetroId} in lane {this.Lane?.Id}");
        }
    }

    public Task OnNoteAdded(NoteAddedNotification notification)
    {
        if (notification.LaneId != this.Lane?.Id ||
            notification.RetroId != this.RetroId.StringId ||
            notification.Note.ParticipantId == this.CurrentParticipant.Id)
        {
            // We can ignore this notification if:
            // 1. This isn't our lane
            // 2. We added this notification (we caused this notification)
            // 3. This isn't our retrospective
            return Task.CompletedTask;
        }

        return this.InvokeAsync(() =>
        {
            this.Contents.Notes.Add(notification.Note);
            
            this.StateHasChanged();
        });
    }
}
